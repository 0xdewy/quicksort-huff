
#define macro RETURN_IF_FINISHED() = takes(1) returns (1) {
    STACK_OFFSET() TOP_LOCATION() gt continue jumpi

    calldatasize ARRAY_MEMORY_SLOT() return

    continue:

}

// Stack Memory Layout: 
// Start = calldatalength + 32
// Ie.  (1 & 2) are on the stack
// 
// 0x00 (StackOffset) = 0x40 (TopOffset = memory location pointing to top of the stack)
// 0x20 (TopOffset) = 1
// 0x40 = 2
// 
#define macro STACK_OFFSET() = takes(0) returns(1) {
    calldatasize 0x56 add
}

#define macro TOP_OFFSET() = takes(0) returns(1) {
    // Return memory position to top of stack (relative to STACK_OFFSET)
    STACK_OFFSET() mload
}

#define macro TOP_LOCATION() = takes(0) returns(1) {
    STACK_OFFSET() dup1     // [stackOffset, stackOffset]
    mload add              // [topOffset+stackOffset]
}

#define macro STACK_POP() = takes(0) returns(1) {
    // Set top of stack back 32 bytes
    TOP_OFFSET()                // [top] 
    0x20                        // [0x20, top]
    dup2 sub                                        // [top - 0x20, top]
    STACK_OFFSET() mstore                      // [top]
    // Load element onto stack
    STACK_OFFSET() add mload
}

#define macro STACK_PUSH() = takes(1) returns(0) {
    // Takes:                            // [item]
    TOP_OFFSET()                         // [offset, item]

    // stack[0] = topOffset + 32
    0x20 add                        // offset+32, item
    swap1 dup2                      // [offset+32, item, offset+32] 
    STACK_OFFSET() mstore       // [item, offset+32]

    // (stackOffset + (topOffset + 32)) : item
    swap1 STACK_OFFSET() add                  // [stackOffset + offset+32, item]
    mstore                     // []
}
